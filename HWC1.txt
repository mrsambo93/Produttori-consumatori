Per la scrittura delle funzioni bloccanti ho optato per la variante offerta dai POSIX thread delle primitive di Hoare. Quindi ho definito un mutex per l'accesso esclusivo al buffer, e 2 condizioni, non_pieno e non_vuoto, per sincronizzare il lavoro dei produttori e dei consumatori. 
I produttori, nel caso di buffer pieno, si metteranno in wait sulla condizione non_pieno ed effettueranno una signal su quella non_vuoto. I consumatori, viceversa, effettueranno una wait su non_vuoto, se il buffer è vuoto, e una signal su non_pieno.
L'approccio, probabilmente, è conservativo in termini di parallelismo, ma ne guadagna in termini di leggibilità, semplicità di implementazione e, sicuramente, in robustezza.
Per le funzioni non bloccanti l'approccio è più semplice, se i produttori, una volta ottenuto il mutex sul buffer, non sono in grado di scrivere perchè non ci sono celle a disposizione, rilasciano il mutex e lanciano un BUFFER_ERROR. Allo stesso modo, i consumatori che trovano il buffer vuoto rilasciano la risorsa e ritornano un BUFFER_ERROR.

Per i test ho cercato di selezionare gli scenari alternandando tra versioni bloccanti e non bloccanti. I test case in cui ho utilizzato i produttori e/o consumatori bloccanti evidenziano il corretto funzionamento della sincronizzazione. Quei test in cui ho usato le versioni non bloccanti cercano invece di evidenziare i casi limite, ovvero quelli in cui dovrebbe essere lanciato un BUFFER_ERROR.   
